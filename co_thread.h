#pragma once


#ifdef __cplusplus
extern "C" {
#endif



#include <stdint.h>


#ifndef CO_THREAD_STACK_SIZE
#define CO_THREAD_STACK_SIZE 1024
#endif


typedef void* co_thread;


typedef void (*co_thread_fn)();



////////////////////////////////////////////////////////////////////////////////
//
// co_ThreadConfiguration
//
// Used to pass configuration settings to co_thread_create.
//
typedef struct co_ThreadConfiguration {

    // Size of the thread's stack. Must be a multiple of eight bytes.
    uint32_t stack_size_;

    // Optionally provide memory for the thread's header and stack. If null, the
    // system will call malloc. If specified, must be eight-byte aligned.
    void* memory_;

} co_ThreadConfiguration;
//
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//
// co_thread_create(entry_point)
//
// Create a thread, with entry point supplied in `entry_point`. You may attach
// an argument to the thread in `arg`, which may be retrieved by calling
// `co_thread_arg()`. Optionally specify aditional settings in the config
// parameter.
//
co_thread co_thread_create(co_thread_fn entry_point,
                           void* arg,
                           co_ThreadConfiguration* config);
//
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//
// co_thread_yield()
//
// Halt execution of the current thread, and switch to another. Does nothing if
// you have not created any threads.
//
void co_thread_yield();
//
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//
// co_thread_resume(thread)
//
// Yield and transfer control to a specific thread. Will return immediately if
// the thread is blocked on a condition.
//
void co_thread_resume(co_thread thread);
//
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//
// co_thread_cond_wait(thread)
//
// Yield, do not schedule the thread until `cond(cond_arg)` evaluates to
// nonzero.
//
void co_thread_cond_wait(int (*cond)(void*), void* cond_arg);
//
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//
// co_thread_exit()
//
// The only correct way to stop a co_thread. In the future, this library might
// perhaps handle thread exit automatically. For now, before returning from the
// entry_point function passed to co_thread_create, you must call
// co_thread_exit() as a final step.
//
// NOTE: co_thread_exit will return immediately and do nothing when called from
// the main thread.
//
void co_thread_exit();
//
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//
// co_thread_arg()
//
// Retrieve the argument passed to co_thread_create().
//
void* co_thread_arg();
//
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//
// co_thread_join()
//
void co_thread_join(co_thread thread);
//
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//
// co_Semaphore
//
typedef struct co_Semaphore {
    int value_;
} co_Semaphore;
//
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//
// co_sem_wait(sem)
//
void co_sem_init(co_Semaphore* sem, int value);
//
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//
// co_sem_wait(sem)
//
void co_sem_wait(co_Semaphore* sem);
//
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//
// co_sem_post(sem)
//
void co_sem_post(co_Semaphore* sem);
//
////////////////////////////////////////////////////////////////////////////////



#ifdef __cplusplus
}
#endif
